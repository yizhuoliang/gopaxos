package main

import (
	"reflect"

	pb "github.com/yizhuoliang/gopaxos"
)

const (
	acceptorNum = 3
	leaderNum   = 2

	// Message types
	COMMAND   = 1
	RESPONSES = 2
	PROPOSAL  = 3
	DECISIONS = 4
	BEAT      = 5
	P1A       = 6
	P1B       = 7
	P2A       = 8
	P2B       = 9
	EMPTY     = 10

	// Roles
	LEADER   = 0
	ACCEPTOR = 1
)

/*
NOTE: Changed names
leaderID / AccID -> me
*/
type State struct {
	me   int32
	role int32

	// For leader
	adoptedBallotNumber int32
	proposals           map[int32]*pb.Proposal
	ongoingCommanders   []*CommanderState
	ongoingScout        *ScoutState
	decisions           []*pb.Decision

	// For acceptor
	ballotNumber int32
	ballotLeader int32
	accepted     [][]*pb.BSC
}

// --- Transformation Functions --

func Apply(s State, msg pb.Message) (State, pb.Message) {
	switch s.role {
	case LEADER:
		s.LeaderApply(s, msg)
	case ACCEPTOR:
		s.AcceptorApply(s, msg)
	default:
		log.Fatalf("unkonwn role type")
	}
}

func LeaderApply(s State, msg pb.Message) (State, pb.Message) {
	reply := pb.Message{}
	switch msg.Type {
	case PROPOSAL:
		s.ProposalTransformation(msg)
	case P1B:
		s.P1BTransformation(msg)
	case P2B:
		s.P2BTransformation(msg)
	}
	return s, reply
}

// Leader
func (s *State) ProposalTransformation(msg pb.Message) {
	_, ok := s.proposals[msg.SlotNumber]
	if !ok {
		p := make(map[int32]*pb.Proposal)
		mapCopy(p, s.proposals)
		s.proposals[msg.SlotNumber] = &pb.Proposal{SlotNumber: msg.SlotNumber, Command: msg.Command}
		s.ongoingCommanders = append(s.ongoingCommanders, &CommanderState{ballotNumber: s.adoptedBallotNumber, bsc: &pb.BSC{BallotNumber: s.adoptedBallotNumber, SlotNumber: msg.SlotNumber, Command: msg.Command}, ackCount: 0})
	}
}

// Leader
func (s *State) P1BTransformation(msg pb.Message) {
	// DROP STALE P1B
	if msg.BallotNumber <= s.adoptedBallotNumber {
		return
	}

	if s.ongoingScout != nil {
		// Case - Stale Scout
		if msg.BallotNumber > s.ongoingScout.ballotNumber || (msg.BallotNumber == s.ongoingScout.ballotNumber && msg.BallotLeader != s.leaderId) {
			s.ongoingScout = nil
		}

		// Case - Current Scout Update
		if msg.BallotNumber == s.ongoingScout.ballotNumber && msg.BallotLeader == s.leaderId && !s.ongoingScout.ackAcceptors[msg.AcceptorId] {
			newScout := new(ScoutState)
			scoutStateCopy(newScout, s.ongoingScout)
			s.ongoingScout = newScout
			s.ongoingScout.ackAcceptors[msg.AcceptorId] = true
			s.ongoingScout.ackCount++
			s.ongoingScout.pvalues = append(s.ongoingScout.pvalues, msg.Accepted...)
		}
	}

	// Case - Register new Scout
	if s.ongoingScout == nil && msg.BallotLeader == s.leaderId {
		newScout := scoutStateConstructor(msg.BallotNumber)
		s.ongoingScout = newScout
		s.ongoingScout.ackAcceptors[msg.AcceptorId] = true
		s.ongoingScout.ackCount++
		s.ongoingScout.pvalues = append(s.ongoingScout.pvalues, msg.Accepted...)
	}

	// TRIGGER ADOPTION
	if s.ongoingScout.ackCount >= acceptorNum/2+1 && s.ongoingScout.ballotNumber > s.adoptedBallotNumber {
		adoption(s)
		// clean-up this scout
		s.ongoingScout = nil
	}
}

// Leader
func (s *State) P2BTransformation(msg pb.Message) {
	copiedCom := false
	copiedDec := false
	for i, commander := range s.ongoingCommanders {
		// since we don't know which commander is this P2B responding, just find all commander that can take this P2B
		if msg.BallotNumber == commander.ballotNumber && msg.BallotLeader == s.leaderId && !commander.ackAcceptors[msg.AcceptorId] {
			if !copiedCom {
				// copy on write
				commanders := make([]*CommanderState, len(s.ongoingCommanders))
				copy(commanders, s.ongoingCommanders)
				s.ongoingCommanders = commanders
				copiedCom = true
			}
			commander.ackAcceptors[msg.AcceptorId] = true
			commander.ackCount++
			// RECORD THIS SLOT BEING DECIDED (assuming that the bsc for the slot in "proposals" won't change latter)
			if commander.ackCount >= acceptorNum/2+1 {
				if !copiedDec {
					// copy on write
					decisions := make([]*pb.Decision, len(s.decisions))
					copy(decisions, s.decisions)
					s.decisions = decisions
					copiedDec = true
				}
				if len(s.decisions) <= int(commander.bsc.SlotNumber) {
					newChunk := make([]*pb.Decision, int(commander.bsc.SlotNumber)-len(s.decisions)+1)
					s.decisions = append(s.decisions, newChunk...) // TODO: test this part
				}
				s.decisions[commander.bsc.SlotNumber] = &pb.Decision{SlotNumber: commander.bsc.SlotNumber, Command: commander.bsc.Command}
				// clean-up this commander
				s.ongoingCommanders = append(s.ongoingCommanders[:i], s.ongoingCommanders[i+1:]...)
			}
			break
		}
	}
}

// Acc
func AcceptorApply(s State, msg pb.Message) (State, pb.Message) {
	reply := pb.Message{}
	switch msg.Type {
	case P1A:
		reply = s.P1ATransformation(msg)
	case P2A:
		reply = s.P2ATransformation(msg)
	}
	return s, reply
}

// Acc
func (s *State) P1ATransformation(msg pb.Message) pb.Message {
	if msg.BallotNumber > s.ballotNumber || (msg.BallotNumber == s.ballotNumber && msg.LeaderId != s.ballotNumber) {
		s.ballotNumber = msg.BallotNumber
		s.ballotLeader = msg.LeaderId
	}
	var acceptedList []*pb.BSC
	for i := 1; i < int(s.ballotNumber); i++ {
		if s.accepted[int32(i)] != nil {
			acceptedList = append(acceptedList, s.accepted[int32(i)]...)
		}
	}
	return pb.Message{Type: P1B, AcceptorId: -1, BallotNumber: s.ballotNumber, BallotLeader: s.ballotLeader, Accepted: acceptedList}
}

// Acc
func (s *State) P2ATransformation(msg pb.Message) pb.Message {
	if msg.Bsc.BallotNumber >= s.ballotNumber && s.ballotLeader == msg.LeaderId {
		s.ballotNumber = msg.Bsc.BallotNumber
		m := make([][]*pb.BSC, len(s.accepted))
		copy(m, s.accepted)
		s.accepted = m
		s.accepted[msg.Bsc.BallotNumber] = append(s.accepted[msg.Bsc.BallotNumber], msg.Bsc)
	}
	return pb.Message{Type: P2B, AcceptorId: -1, BallotNumber: s.ballotNumber, BallotLeader: s.ballotLeader}
}
